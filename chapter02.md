변수와 상수
===

예제 훑어보기
---

지난 시간에 작성했던 예제를 돌아봅시다.

```c
#include <stdio.h>

void main() {
    printf("Hello, KCA!\n");
}
```

이 소스코드를 차례대로 분석해보도록 하겠습니다.

먼저 맨 첫번째 줄에 `#include <stdio.h>` 라는 코드를 확인할 수 있습니다.    
C언어에서 이렇게 `#` 으로 시작하는 것은 **전처리기 지시어** 입니다.    
이것은 `stdio.h` 라는 이름의 헤더 파일을 소스 코드에 포함시킵니다.    

> **헤더 파일 _header file_**    
코드의 일부분이 들어 있는 텍스트 파일로, 함수나 변수를 직접 선언하지 않고 다른 사람이 만들어둔 것을 사용할 수 있도록 해둔 외부 라이브러리다.    
일단 "다른 사람이 가져다 쓸 수 있도록 만들어 놓은 파일"이라고 생각하고 넘어가자.    

`stdio.h` 는 _**ST**an**D**ard **I**nput/**O**utput_ 의 약자로, C언어 표준 입출력 함수가 선언되어 있는 헤더 파일입니다.    
함수가 무엇인지는 이후에 자세히 알아보도록 하고, 그런 게 있구나 하고 넘어갑시다.    

그 아래로는 `void main() {` 으로 시작하여 `}` 로 끝나는 코드가 존재합니다.    
이렇게 `{` 와 `}` 로 감싼 영역을 **코드 블럭 _code block_** 이라고 합니다.    
`void` 는 C언어에 존재하는 자료형 중 하나인데, `void main()` 과 같이 `자료형 식별자()` 형태의 코드를 함수라고 합니다.    
정확히는 `자료형 식별자()` 부분을 함수의 **원형 _prototype_**, 코드 블럭 부분을 함수의 **본문 _body_** 이라고 하죠.    
함수는 단 한 번 코드 블럭을 사용하여 정의해야 사용할 수 있으며, 같은 이름의 함수를 두 번 이상 정의하거나 한 번도 정의하지 않고 사용하려고 하면 오류가 발생합니다.    
`void main()` 은 C언어의 특별한 함수로 반드시 정의해주어야 하며, C언어로 작성된 프로그램을 실행하면 이 녀석이 실행됩니다.    
함수를 실행시키는 것을 함수를 **호출한다 _call_** 고 하는데, `void main()` 은 운영체제가 호출하지만 그 외의 함수를 호출할 때는 함수의 식별자를 적어주어야 합니다.    
프로그램 내에서 함수를 식별할 수 있는 이름이죠.    
앞에 붙은 자료형은 생략하고 뒤에 세미콜론을 붙인 채 `main();` 과 같은 형식으로 호출합니다.    
함수를 호출하면 함수를 정의할 때 코드 블럭에 작성한 내용이 차례대로 실행됩니다.    
이 예제에서는 `printf("Hello, KCA!\n");` 가 실행되겠죠.    

`printf("Hello, KCA!\n");` 또한 함수 호출에 해당합니다.    
함수의 괄호 안에는 함수를 호출할 때 전달하고자 하는 자료를 담을 수 있는데, 이를 **인자 _argument_** 라고 합니다.    
함수에 인자를 전달하기 위해서는 해당 함수를 정의할 때 함수 원형 괄호에 **매개변수 _parameter_** 를 지정해주어야 합니다.    
예를 들어, `printf()` 함수는 `stdio.h` 에 `int printf (const char *__restrict __format, ...)` 와 같은 형태로 작성되어 있는데, 여기서 괄호 안에 있는 `const char *__restrict __format` 과 같은 부분인 매개변수에 해당합니다.     

함수에 대한 이야기는 추후에 자세히 하도록 하고, `printf` 라는 이름의 함수에 `"Hello, KCA!\n"` 를 전달했다는 것 정도만 이해하고 넘어갑시다.    
`printf` 는 특정한 형식(**F**ormat)의 텍스트를 출력(**PRINT**)하는 함수입니다.    
형식을 지정하는 방식에 대해서는 잠시 후에 알아보도록 하고, 여기선 따로 형식을 지정해주지 않았으니 전달된 텍스트가 그대로 출력됩니다.    
이 때, `\n` 는 그대로 출력되지 않고 한 줄 개행하는 것으로 대체됩니다.    
이와 같이 `\` 에 문자 하나가 붙어 있는 것은 **이스케이프 시퀀스 _escape sequence_** 라는, 특별한 의미를 갖는 문자입니다.    
결론적으로 이 함수를 통해 `Hello, KCA!` 가 화면에 출력되는 것이죠.    

이 텍스트를 출력하고나면 `main` 이라는 이름의 함수의 끝에 도달합니다.
이것이 이 프로그램의 마지막이죠.

이제 이러한 C언어 프로그램을 작성하기 위해 알아야 할 조각조각들을 하나씩 알아보도록 합시다.

데이터를 저장하는 공간
---

우리 예제에서는 간단한 텍스트를 출력하는 것이었기에 어떤 자료를 저장해놓을 필요가 없었습니다.    
하지만 때로는 어떤 자료를 프로그램 내에 저장해놓고 사용해야 할 때가 있습니다.    

가령 두 숫자 사이의 사칙연산을 한다거나, 어떤 도형의 넓이나 둘레 길이를 구하고자 할 때, 입력 받은 숫자, 한 변의 길이 등의 자료를 저장해놓고 계산할 필요가 있죠.    

이런 경우에 C언어에서는 **변수 _variable_** 라고 불리는 메모리 공간을 사용합니다.    
변수는 그 값을 변경할 수 있다(variable)는 이유에서 **변(變)** 수라고 하며, 변**수(數)** 이기는 하지만 반드시 숫자일 필요는 없습니다.    
~~(물론 내부적으로는 모두 0과 1로 구성되기 때문에 숫자로 기록되긴 합니다만...ㅋ)~~    

변수는 정해진 크기의 메모리 공간입니다.    
그 변수가 무엇을 담고 있느냐에 따라 그 크기가 달라지죠.    
변수가 담고 있는 자료의 종류는 **자료형 _data type_** 으로 나타냅니다.    

### 자료형 _data type_

C언어의 기본 자료형은 크게 정수형과 실수형, 그리고 문자형으로 나뉩니다.    

먼저 **정수형** 은 소수점 아래로 내려가지 않는 숫자를 표현하는 자료형으로, 그것이 차지하는 공간의 크기와 부호의 유무를 기준으로 세부적으로 나뉩니다.    

|부호 유무|바이트 수|자료형|설명|범위|
|:-:|:-:|:-:|:-:|:-:|
|O|2-byte|`short`|`short` 형 정수|-32768 ~ 32767|
|O|4-byte|`int`|정수|-2147483648 ~ 2147483647|
|O|4-byte|`long`|`long` 형 정수|-2147483648 ~ 2147483647|
|X|2-byte|`unsigned short`|부호 없는 `short` 형 정수|0 ~ 65535|
|X|4-byte|`unsigned int`|부호 없는 정수|0 ~ 4294967295|
|X|4-byte|`unsigned long`|부호 없는 `long` 형 정수|0 ~ 4294967295|

`int` 의 크기는 4-byte인 게 일반적이지만 CPU에 따라 차이가 있으며, 8-byte 크기의 `long long` 자료형을 사용할 수 있는 경우도 있습니다.    
n-byte 정수 자료형에 대해서 부호가 있는 자료형은 -2<sup>(8n-1)</sup> 부터 2<sup>(8n-1)</sup> - 1 까지, 부호가 없는 자료형은 0부터 2<sup>8n</sup>-1 까지의 값을 갖습니다.    
이는 1byte가 8bit이며 각각의 bit는 0과 1 두 가지 값을 표현할 수 있기에 bit가 1 증가할수록 표현 가능한 숫자가 두 배로 늘어나기 때문입니다.    

만약 어떤 자료형에 그 자료형이 표현할 수 있는 범위를 벗어난 값이 입력된다면, 범위를 넘어서는 순간 범위의 반대쪽 끝부터 다시 시작합니다.    
가령 `short` 자료형에 40000이라는 숫자가 들어간다면, 32767을 넘어선 순간 -32768부터 다시 시작하여 -25526으로 취급됩니다.    
반대로 -32768보다 작은 숫자가 들어가도 32767에서부터 다시 시작합니다.    
이와 같이 주어진 범위를 벗어나 의도했던 값이 아닌 다른 값이 저장되는 것을 **오버플로우 _overflow_** 라고 합니다.    
큰 수의 연산에서는 이와 같은 오버플로우가 발생하지 않도록 주의해야 합니다.    

다음으로, **실수형** 은 소수점 아래로 내려가는 숫자를 표현하는 자료형으로, 그 정확도에 따라 두 가지로 나뉩니다.    

|바이트 수|자료형|설명|범위|
|:-:|:-:|:-:|:-:|
|4-byte|`float`|단일정밀도 부동 소수점|±1.17549×10<sup>-38</sup> ~ ±3.40282×10<sup>+38</sup>|
|8-byte|`double`|두배정밀도 부동 소수점|±2.22507×10<sup>-308</sup> ~ ±1.79769×10<sup>+308</sup>|

`double` 은 `float` 에 비해 정확도가 높은 대신 그만큼 많은 공간을 차지합니다.    
그런데 요즘 컴퓨터는 메모리 크기도 널널해서 `float` 보다 `double` 을 사용하는 경향이 있죠.    
실수는 `3.141592` 같이 일반적인 형태의 실수로 표기할 수도 있고, 정수부분의 0인 경우에는 `.5` 처럼 정수 부분을 생략할 수도 있습니다.    
소수 부분이 없는 경우에는 `4.` 와 같이 표기함으로써 정수가 아닌 실수로 표현할 수 있죠.    
또한 지수 표기법으로도 표현이 가능한데, 소수부와 지수부 사이에 공백 없이 `e` 또는 `E` 를 넣어 `2.34E3` 이나 `54.21E-7` 처럼 사용할 수 있습니다.

실수형도 범위를 벗어나면 의도하지 않은 값이 저장되는데, 실수형의 경우 너무 크거나 너무 작아도 문제가 발생하지만 0에 가까운 너무 세밀한 숫자여도 문제가 발생합니다.    
0은 그냥 0으로 인식되지만, 0이 아닌 아주 작은 숫자는 실수형으로 표현하지 못할 수 있는데, 이러한 경우는 **언더플로우 _underflow_** 라고 부릅니다.    

그리고 **문자형** 은 하나의 문자를 저장하기 위해 사용됩니다.    
문자는 기본적으로 **ASCII코드** 라는, 1byte 문자체계로 저장되는데, 이것은 영어 대소문자와 숫자, 그리고 주요 기호들과 특수한 의미를 갖는 제어 문자로 이루어져 있습니다.    
한글을 입력할 경우 2byte짜리 **UNICODE** 로 저장되는데, C언어의 문자형은 ASCII코드에 맞춰 1byte 크기이기 때문에 한글을 저장하기 위해서는 문자형 자료 두 개가 필요합니다.    

|바이트 수|자료형|설명|
|:-:|:-:|:-:|
|1-byte|`char`|문자|

ASCII코드는 외울 필요 없고, 굳이 꼭 알아야 하는 상황이 오면 구글에게 물어보도록 합시다.    

|Dec|Hex|Char|Dec|Hec|Char|Dec|Hex|Char|Dec|Hec|Char|Dec|Hex|Char|Dec|Hec|Char|Dec|Hex|Char|Dec|Hec|Char|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|0|0x00|[NULL]|16|0x10|[DLE]|32|0x20|[space]|48|0x30|0|64|0x40|@|80|0x50|P|96|0x60|`|112|0x70|p|
|1|0x01|[SOH]|17|0x11|[DC1]|33|0x21|!|49|0x31|1|65|0x41|A|81|0x51|Q|97|0x61|a|113|0x71|q|
|2|0x02|[STX]|18|0x12|[DC2]|34|0x22|"|50|0x32|2|66|0x42|B|82|0x52|R|98|0x62|b|114|0x72|r|
|3|0x03|[ETX]|19|0x13|[DC3]|35|0x23|#|51|0x33|3|67|0x43|C|83|0x53|S|99|0x63|c|115|0x73|s|
|4|0x04|[EOL]|20|0x14|[DC4]|36|0x24|$|52|0x34|4|68|0x44|D|84|0x54|T|100|0x64|d|116|0x74|t|
|5|0x05|[ENQ]|21|0x15|[NAK]|37|0x25|%|53|0x35|5|69|0x45|E|85|0x55|U|101|0x65|e|117|0x75|u|
|6|0x06|[ACK]|22|0x16|[SYN]|38|0x26|&|54|0x36|6|70|0x46|F|86|0x56|V|102|0x66|f|118|0x76|v|
|7|0x07|[BEL]|23|0x17|[ETB]|39|0x27|'|55|0x37|7|71|0x47|G|87|0x57|W|103|0x67|g|119|0x77|w|
|8|0x08|[BS]|24|0x18|[CAN]|40|0x28|(|56|0x38|8|72|0x48|H|88|0x58|X|104|0x68|h|120|0x78|x|
|9|0x09|[HT]|25|0x19|[EM]|41|0x29|)|57|0x39|9|73|0x49|I|89|0x59|Y|105|0x69|i|121|0x79|y|
|10|0x0A|[LF]|26|0x1A|[SUB]|42|0x2A|*|58|0x3A|:|74|0x4A|J|90|0x5A|Z|106|0x6A|j|122|0x7A|z|
|11|0x0B|[VT]|27|0x1B|[ESC]|43|0x2B|+|59|0x3B|;|75|0x4B|K|91|0x5B|[|107|0x6B|k|123|0x7B|{|
|12|0x0C|[FF]|28|0x1C|[FS]|44|0x2C|,|60|0x3C|<|76|0x4C|L|92|0x5C|\ |108|0x6C|l|124|0x7C|\||
|13|0x0D|[CR]|29|0x1D|[GS]|45|0x2D|-|61|0x3D|=|77|0x4D|M|93|0x5D|]|109|0x6D|m|125|0x7D|}|
|14|0x0E|[SO]|30|0x1E|[RS]|46|0x2E|.|62|0x3E|>|78|0x4E|N|94|0x5E|^|110|0x6E|n|126|0x7E|~|
|15|0x0F|[SI]|31|0x1F|[US]|47|0x2F|/|63|0x3F|?|79|0x4F|O|95|0x5F|_|111|0x6F|o|127|0x7F|[DEL]|

문자를 나타낼 땐 `'a'` 와 같이 따옴표로 묶어 사용합니다.    
둘 이상의 문자를 함께 사용하려면 큰따음표로 묶은 **문자열 _string_** 을 사용해야 하는데, 이에 대해서는 나중에 알아보도록 하겠습니다.

ASCII코드 외에 자주 사용되는 문자로는 **이스케이프 시퀀스 _escape sequence_** 라는 특별한 의미를 가진 제어 문자들이 있습니다.    
이것은 `\` 로 시작하며, 두 개의 문자로 이루어져 있지만 합쳐서 하나의 문자로 취급됩니다.    

|제어 문자|이름|의미|
|:-:|:-:|:-:|
|\0|널(NULL)|비어 있음을 의미|
|\a|경고음(bell)|'삐' 하는 경고음 발생|
|\b|백스페이스(backspace)|커서를 현재 위치에서 한 글자 뒤로 이동|
|\f|폼 피드(form feed)|(프린터에서) 페이지 끝에 도달하지 않았을 때 강제로 다음 페이지로 넘김|
|\n|개행(new line)|커서를 다음 줄의 시작 위치로 이동|
|\r|캐리지 리턴(carriage return)|커서를 현재 줄의 시작 위치로 이동|
|\t|수평 탭(horizontal tab)|커서를 현재 줄에 설정된 다음 탭 위치로 이동|
|\v|수직 탭(vertical tab)|커서를 설정되어 있는 다음 수직 탭 위치로 이동|
|\\'|작은 따옴표|`'` 로 묶는 문자 내에서 작은 따옴표를 출력할 때 사용|
|\\"|큰 따옴표|`"` 로 묶는 문자열 내에서 큰 따옴표를 출력할 때 사용|
|\\\\ |역슬래시(back slash)|이스케이프 시퀀스가 아닌 역슬래시 자체를 출력할 때 사용|

그 외에도 그 어떤 자료형도 아님을 의미하는 무치형 `void` 라던가 연관된 일련의 정수값들에 이름을 붙이는 데 사용되는 열거형 `enum` 등이 있지만 일단 기본 자료형들만 알고 넘어갑시다.    

앞서, `printf` 는 특정한 형식의 텍스트를 출력한다고 했습니다.    
이것은 기본적으로 큰 따옴표로 묶여 있는 텍스트를 출력하는데, 예외적으로 **형식 지정자** 와 **이스케이프 시퀀스** 는 있는 그대로 출력하지 않고 특별한 의미로 사용됩니다.    
이스케이프 시퀀스는 잠시 후, 문자 자료형에 대해 이야기할 때 다시 살펴보도록 하고 형식 지정자에 대한 이야기를 하겠습니다.    
형식 지정자는 `%` 로 시작하며, 출력할 땐 어떤 자료의 값으로 대치됩니다.    
어떤 자료로 대치할지는 `printf` 에 `,` 를 기준으로 띄워 전달하죠.    
예를 들어, `int` 의 형식 지정자는 `%d` 인데, 다음과 같은 코드를 실행하면,

```c
#include <stdio.h>

void main() {
    printf("number: %d\n:, 78");
}
```

다음과 같이 출력되는 것을 확인할 수 있습니다.

```
number: 78
```

형식 지정자는 출력할 때 말고도 입력할 때도 사용되는데, 그 경우 입력될 자료의 자료형을 미리 특정하는 데 사용됩니다.    
형식 지정자의 종류는 다음과 같습니다.    
(지금 다 외우려고 할 필요는 없고, 필요할 때 찾아보면서 차차 익숙해집시다.)    

|형식 지정자|의미|자료형|
|:-:|:-:|:-:|
|`d`|부호가 있는 10진수 정수 (입력 시 10진수만 입력 가능)|`short`, `int`, `long`, `char`|
|`i`|부호가 있는 10진수 정수 (입력 시 8진수, 16진수 입력 가능)|`short`, `int`, `long`, `char`|
|`u`|부호가 없는 10진수 정수|`unsigned short`, `unsigned int`, `unsigned long`, `unsigned char`|
|`o`|부호가 없는 8진수 정수|`short`, `int`, `long`, `unsigned short`, `unsigned int`, `unsigned long`, `char`, `unsigned char`|
|`x` 또는 `X`|부호가 없는 16진 정수|`short`, `int`, `long`, `unsigned short`, `unsigned int`, `unsigned long`, `char`, `unsigned char`|
|`l`|`d`, `i`, `u`, `o`, `x`, `X` 에 대한 `long` 접두사|`long`, `double`|
|`h`|`d`, `i`, `u`, `o`, `x`, `X` 에 대한 `short` 접두사|`short`|
|`f`|부호 있는 실수|`float`, `double`|
|`e`|부호 있는 실수의 과학적 표기법|`float`, `double`|
|`g`|`f`와 `e` 중 상대적으로 짧은 형식 사용|`float`, `double`|
|`c`|단일 문자|`char`, `unsigned char`|
|`s`|문자열 (아직 안배웠지만 큰따옴표로 묶인 텍스트)|`char*`|
|`p`|포인터 (아직 안배웠지만... 나중에 이야기 하자)|(이것도 나중에 이야기 하자)|

사실 그 외에도 `m` 으로 시작되는 형식 지정자라던가, 문자열 인코딩에 따른 형식 지정자라던가 더 있지만 이 정도만 알아도 충분합니다.    

### 변수 _variable_

C언어의 자료는 기본적으로 변수의 형태로 사용합니다.    
변수는 `자료형 식별자;` 형태로 생성할 수 있으며, 변수를 생성하는 것을 변수의 **선언 _declare_** 이라고 합니다.    

식별자는 서로 다른 변수를 구분하기 위한 고유한 이름으로, 몇 가지 규칙에 의해 작성할 수 있습니다.    

- 영문자와 숫자, 그리고 밑줄 문자 `_` 로 이루어진다.    
(일부 컴파일러에서는 한글로 된 변수도 지원하지만 호환성을 위해서 비추...)
- 중간에 띄어쓰기나 탭 같은 공백을 사용할 수 없다.    
- 숫자로 시작하지 않도록 해야 한다.
- 대소문자를 구분한다.
- 키워드와 동일한 이름을 가질 수 없다.

> **키워드 _keyword_**    
고유한 의미를 가진 특별한 단어    
예약어(reserved word)라고도 불리며, 사용자가 다시 정의하여 사용할 수 없다.    
C언어의 키워드는 다음과 같으며, 컴파일러나 시스템에 따라 더 추가될 수 있다.    
`auto` | `break` | `case` | `char` | `const` | `continue` | `default` | `do` | `double` | `else` | `enum` | `extern` | `float` | `for` | `goto` | `if` | `int` | `long` | `register` | `return` | `short` | `signed` | `sizeof` | `static` | `struct` | `switch` | `typeof` | `union` | `unsigned` | `void` | `volatile` | `while`

변수의 식별자은 간결하면서도 그 변수의 역할을 잘 설명하는 이름으로 설정하는 것이 좋습니다.    
예를 들어, 크기를 나타내는 변수는 `size` , 개수를 나타내는 변수는 `count` , 이런 식으로 말이죠.    
때로는 한 단어로 표현하기 어려운 경우도 있는데 이런 경우에는 띄어쓰기를 사용할 수 없으므로 붙여 써야 합니다.    
다만, 그냥 붙여 쓰면 가독성이 떨어지므로 주로 다음과 같은 두 가지 방식 중 하나를 선택하여 사용합니다.    

- **뱀 표기법 _snake case_**    
띄어쓰기 대신 밑줄 문자 `_`를 사용하는 방식    
예를 들어, `server_socket` 과 같이 사용    
- **낙타 표기법 _camel case_**    
두번째 단어부터 첫글자를 대문자로 쓰는 방식
예를 들어, `serverSocket` 과 같이 사용    

어떤 표기법을 사용하는지는 개인 취향 차이이긴 하지만 대부분의 프로그래밍 언어는 주로 사용되는 방식이 있습니다.    
C언어에서는 전통적으로 뱀 표기법이 사용됩니다.    
~~사실 이런 건 회사마다, 프로젝트마다 정해진 관례가 있으므로... 상황에 따라 달라질 수 있습니다.~~

이와 같은 식별자 규칙을 사용하여 변수를 선언해보면,

```c
int count;
double probability;
char grade;
int best_score;
```

변수의 선언은 자료를 위한 공간을 마련하는 것뿐, 그 어떤 자료도 갖고 있지 않습니다.    
실제적으로 변수를 사용하기 위해서는 변수에 값을 넣어주어야 합니다.    
비어있는 변수에 최초로 값을 넣어주는 작업을 **초기화 _initialize_** 라고 합니다.    
초기화는 대입 연산자 `=` 를 통해 수행할 수 있으며, 다음과 같이 선언 후에 초기화 하거나    

```c
char grade;
grade = 'F';
```

다음과 같이 선언과 함께 초기화 합니다.

```c
char grade = 'F';
```

그리고 변수는 변할 수 있다는 이름 그대로, 초기화 이후에 다른 값을 대입할 수 있습니다.    


```c
char grade = 'F';
grade = 'A';
```

### 상수 _constant_

상수는 변수와 크게 다르지 않습니다.    
단 하나의 차이가 있다면 상수는 그 값을 바꿀 수 없다는 것이죠.    
상수는 실행 도중에 그 값이 변경되어서는 안되는 경우에 사용합니다.    
개발자가 실수로라도 코드 상에서 그 값을 변경하지 못하도록 말이죠.    
가령 어떤 프로그램에서 π를 `double pi = 3.141592;` 로 사용하고 있었는데 어느 시점에 이걸 `pi = 3.14;` 로 변경했다고 합시다.    
그렇다면 그 변경 전후로 연산의 정확도가 달라지며 의도치 않은 결과를 야기할 수 있습니다.    
이런 상황을 방지하기 위해 `pi` 를 변수가 아닌 상수로 선언할 수 있습니다.    

상수 선언은 _1. 키워드를 사용하는 방식_ 과  _2. 전처리기를 사용하는 방식_ 두 가지가 있습니다.

먼저, 키워드를 사용하는 방식은 변수를 선언하는 것처럼 하되, 자료형 앞에 `const` 라는 키워드를 붙여 줍니다.    

```c
const double pi = 3.141592;
```

이 때, 상수에는 값을 대입할 수 없기 때문에 반드시 선언과 함께 초기화를 해주어야 합니다.    

상수를 선언하는 또 다른 방법인 전처리기를 사용하는 방식에서는 `#define` 을 사용합니다.    
C 파일 상단에서 다음과 같이 작성함으로써 코드 상의 모든 `PI` 를 `3.141592` 로 대치할 수 있습니다.    

```c
#define PI 3.141592
```

상수는 관습적으로 대문자로 선언합니다.    
위의 `const` 방식에서도 다음과 같이 작성하는 게 일반적이죠.

```c
const double PI = 3.141592;
```

이는 상수와 변수를 구분하여 상수에는 어떤 값을 대입하려는 시도를 하지 않도록 하는 의미가 있으며, 전처리기 방식에서는 혹시 모를 버그를 방지하기 위함입니다.    

혹시 모를 버그라는 것은, `#define` 이 해당 텍스트와 일치하는 코드 상의 모든 것을 해당 값으로 대치하기 때문에 발생합니다.    
예를 들어, 다음과 같은 코드가 있을 때,

```c
#define on 1
#define off 0

void main() {
    long value = 0;
    int status = off;

    do_something();
}
```

위 코드는 다음과 같이 대치되어 컴파일 오류가 발생합니다.

```c
void main() {
    l1g value = 0;
    int status = 0;

    do_something();
}
```

`long` 의 `on` 마저도 `1` 로 대치해버린 것입니다!    
따라서 상수만 대문자로 쓰고 나머지는 소문자로 씀으로써 의도치 않은 변환을 방지합니다.

### 리터럴 _literal_
변수나 상수에 대입할 수 있는 구체적인 값을 **리터럴 _literal_** 이라고 합니다.    
`3.141592` 라던가 `78` 라던가 `'K'` 같은 것들이죠.    
지난 번에 출력해 본 `"Hello, KCA!\n"` 또한 리터럴입니다.

수학적으로는 이런 값들을 상수라고 하지만 `const` 상수와의 구분을 위해 컴퓨터공학에서는 이를 리터럴이라고 부르죠.    

리터럴 정수를 사용하면 기본적으로 `int` 로 취급됩니다.    
`int` 가 아닌 다른 자료형의 리터럴 정수를 사용하고자 한다면 어떤 접미사를 붙여 주어야 합니다.    

|자료형|접미사|
|:-:|:-:|
|`int`||
|`unsigned int`|u, U|
|`long`|l, L|
|`unsigned long`|ul, UL|

`long` 자료형의 `123` 을 사용하고자 한다면 `123L` 라고 작성하는 거죠.    

마찬가지로 리터럴 실수의 경우 기본적으로 `double` 로 취급되며, `float` 을 위해서는 접미사가 필요합니다.    

|자료형|접미사|
|:-:|:-:|
|`double`||
|`float`|f, F|

`float` 자료형의 `3.14` 를 사용하고자 한다면 `3.14F` 라고 작성하는 거죠.

주석
---

마지막으로 자료형이나 변수, 상수하고는 무관하지만, **주석 _comment_** 에 대해 알아보도록 하겠습니다.    
이것은 사람이 코드에 대한 설명을 적어놓기 위한 것으로, 컴파일러는 이것을 무시합니다.    
코드를 한참 뒤에 봤을 때, 혹은 다른 사람이 봤을 때 그 흐름을 이해하는 데 도움이 되돌록 하는 것이죠.

|주석|설명|예시
|:-:|:-:|:-:|
|`//`|이것 이후로 그 줄의 모든 내용이 주석|`코드 코드 // 주석 주석 주석`|
|`/*`, `*/`|여러 줄에 걸쳐 사용할 수 있으며 사이 내용이 주석|`코드 코드 /* 주석 주석 */ 코드`|

짧고 간단한 프로그램을 작성할 때는 주석이 없어도 상관 없지만, 코딩을 할 때 주석을 작성하는 습관을 들이도록 합시다.    

코드에 대한 설명 외에도 라이선스 정보 등을 주석으로 적어놓기도 하죠.

과제
---

이번 주에는 뭔가 많은 내용이 스쳐 지나갔군요!    
그런데 대체로 지금 당장 외울 필요는 없고, 필요할 때 찾아보는 것으로 충분합니다.    
C언어 자료형이 어떤 것들이 있고 변수는 어떻게 선언 및 초기화하는지 정도만 기억해둡시다.    
형식 지정자는 입출력 시에 해당 자료형에는 어떤 형식 지정자를 사용하는지 그 때 가서 찾아보면 되죠.    
물론 익숙해지고 기억을 한다면 코딩 속도가 보다 빨라지긴 하겠죠?    

아무튼 이번 주 과제입니다!    
지난 시간에 생성한 본인 디렉토리에 `chapter02` 디렉토리를 만들어 그 안에 `variables.c` 파일을 생성합니다.    
그리고 다음과 같이 작성한 뒤,

```c
#include <stdio.h>

void main() {
    int example = 78;
    // 서로 다른 자료형의 변수 3개 이상 선언 및 초기화

    printf("%d\n", example);
    // 앞서 선언한 모든 변수를 한 줄에 하나씩 출력
}
```

주석 아래에 서로 다른 자료형의 변수를 3개 이상 선언 및 초기화하는 코드와 그것들을 출력하는 코드를 추가합니다.    
그리고 이를 컴파일하여 실행 화면을 캡처하고 C 소스 파일, 실행 파일, 스크린샷 이미지 파일을 git 저장소에 올려 PR을 보내주시면 됩니다.    

과제를 성공적으로 완료하였다고 판단되면 merge 해드리며, 그렇지 않을 경우 comment로 피드백 드리겠습니다.    
